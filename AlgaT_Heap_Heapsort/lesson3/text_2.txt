L’algoritmo di heapsort() prevede prima di tutto di trasformare il vettore A[1 … n] in input in un vettore che rispetti le proprietà di un vettore maxHeap, quindi per prima cosa viene applicato il metodo heapBuild(). Una volta ottenuto un vettore maxHeap inizia la procedura vera e propria di ordinamento. Prendiamo l’elemento in posizione A[1] (il più grande del vettore) e lo scambiamo con l’elemento in posizione A[n]. Avendo l’elemento più grande nell’ultima posizione, applichiamo maxHeapRestore() sul restante vettore A[1 … n-1] e ripetiamo l’operazione lavorando su A[1 … n-1] fino a A[1 … 2], ottenendo un vettore ordinato. 
Come detto in precedenza, la complessità di heapsort() è ottima. Data la complessità O(n) di heapBuild() e sapendo che l’altezza di un albero heap di n elementi è log n, allora ogni chiamata di maxHeapRestore() costerà O(log n). Poiché maxHeapRestore() viene chiamata un O(n) volte, allora possiamo concludere che la complessità di heapsort() sia O(n log n).
